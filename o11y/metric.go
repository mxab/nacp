package o11y

import (
	"context"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

// DO NOT MODIFY: This code is autogenerated.
// See templates/registry/go/metric.go.j2.



// This is used as a helper for all optional attributes.
type attr struct {
	kv attribute.KeyValue
}
func (a attr) attr() attribute.KeyValue {
    return a.kv
}








// An instrument for recording `nacp.validator.error.count`
type NacpValidatorErrorCount struct {
    inst metric.Float64Counter
}

// Construct a new instrument for measuring `nacp.validator.error.count`
func NewNacpValidatorErrorCount(m metric.Meter) (NacpValidatorErrorCount, error) {
    i, err := m.Float64Counter(
        "nacp.validator.error.count",
        metric.WithDescription("Count of all validation errors produced by the NACP."),
        metric.WithUnit("{validation_error}"),
    )
    if err != nil {
        return NacpValidatorErrorCount{}, err
    }
    return NacpValidatorErrorCount{i}, nil
}





// Adds an increment to the existing count.
func (m NacpValidatorErrorCount) Add(
    ctx context.Context,
    inc float64,

    // The name of the validator.
    validatorName string,


) {

    m.inst.Add(ctx, inc, metric.WithAttributes(


        attribute.String("validator.name", validatorName),


    ))
}












// An instrument for recording `nacp.validator.warning.count`
type NacpValidatorWarningCount struct {
    inst metric.Float64Counter
}

// Construct a new instrument for measuring `nacp.validator.warning.count`
func NewNacpValidatorWarningCount(m metric.Meter) (NacpValidatorWarningCount, error) {
    i, err := m.Float64Counter(
        "nacp.validator.warning.count",
        metric.WithDescription("Count of all validation warnings produced by the NACP."),
        metric.WithUnit("{validation_warning}"),
    )
    if err != nil {
        return NacpValidatorWarningCount{}, err
    }
    return NacpValidatorWarningCount{i}, nil
}





// Adds an increment to the existing count.
func (m NacpValidatorWarningCount) Add(
    ctx context.Context,
    inc float64,

    // The name of the validator.
    validatorName string,


) {

    m.inst.Add(ctx, inc, metric.WithAttributes(


        attribute.String("validator.name", validatorName),


    ))
}












// An instrument for recording `nacp.mutator.error.count`
type NacpMutatorErrorCount struct {
    inst metric.Float64Counter
}

// Construct a new instrument for measuring `nacp.mutator.error.count`
func NewNacpMutatorErrorCount(m metric.Meter) (NacpMutatorErrorCount, error) {
    i, err := m.Float64Counter(
        "nacp.mutator.error.count",
        metric.WithDescription("Count of all mutation errors produced by the NACP."),
        metric.WithUnit("{mutation_error}"),
    )
    if err != nil {
        return NacpMutatorErrorCount{}, err
    }
    return NacpMutatorErrorCount{i}, nil
}





// Adds an increment to the existing count.
func (m NacpMutatorErrorCount) Add(
    ctx context.Context,
    inc float64,

    // The name of the mutator.
    mutatorName string,


) {

    m.inst.Add(ctx, inc, metric.WithAttributes(


        attribute.String("mutator.name", mutatorName),


    ))
}












// An instrument for recording `nacp.mutator.warning.count`
type NacpMutatorWarningCount struct {
    inst metric.Float64Counter
}

// Construct a new instrument for measuring `nacp.mutator.warning.count`
func NewNacpMutatorWarningCount(m metric.Meter) (NacpMutatorWarningCount, error) {
    i, err := m.Float64Counter(
        "nacp.mutator.warning.count",
        metric.WithDescription("Count of all mutation warnings produced by the NACP."),
        metric.WithUnit("{mutation_warning}"),
    )
    if err != nil {
        return NacpMutatorWarningCount{}, err
    }
    return NacpMutatorWarningCount{i}, nil
}





// Adds an increment to the existing count.
func (m NacpMutatorWarningCount) Add(
    ctx context.Context,
    inc float64,

    // The name of the mutator.
    mutatorName string,


) {

    m.inst.Add(ctx, inc, metric.WithAttributes(


        attribute.String("mutator.name", mutatorName),


    ))
}












// An instrument for recording `nacp.mutator.mutation.count`
type NacpMutatorMutationCount struct {
    inst metric.Float64Counter
}

// Construct a new instrument for measuring `nacp.mutator.mutation.count`
func NewNacpMutatorMutationCount(m metric.Meter) (NacpMutatorMutationCount, error) {
    i, err := m.Float64Counter(
        "nacp.mutator.mutation.count",
        metric.WithDescription("Count of all mutations produced by the NACP."),
        metric.WithUnit("{mutation}"),
    )
    if err != nil {
        return NacpMutatorMutationCount{}, err
    }
    return NacpMutatorMutationCount{i}, nil
}





// Adds an increment to the existing count.
func (m NacpMutatorMutationCount) Add(
    ctx context.Context,
    inc float64,

    // The name of the mutator.
    mutatorName string,


) {

    m.inst.Add(ctx, inc, metric.WithAttributes(


        attribute.String("mutator.name", mutatorName),


    ))
}
