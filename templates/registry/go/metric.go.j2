{%- macro smart_title_case(text) -%}
{%- for i in range(0, text | length) -%}
    {%- if i == 0 or text[i-1] in ['.', '_'] -%}
        {{ text[i] | upper }}
    {%- elif not text[i] in ['.', '_'] -%}
        {{ text[i] }}
    {%- endif -%}
{%- endfor -%}
{%- endmacro -%}
{%- macro attribute_struct_field(attr) %}{{ smart_title_case(attr.name) }} {% if attr.requirement_level != "required" %}*{% endif %}{{attr.type | map_text("attribute_type_value") }}{%- endmacro -%}
package o11y

import (
	"context"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

// DO NOT MODIFY: This code is autogenerated.
// See templates/registry/go/metric.go.j2.

{# TODO - only generate this if we have any optional attirbutes. #}
{# ORIGINAL: https://raw.githubusercontent.com/jsuereth/o11y-by-design/refs/heads/main/templates/registry/go/metric.go.j2 #}
// This is used as a helper for all optional attributes.
type attr struct {
	kv attribute.KeyValue
}
func (a attr) attr() attribute.KeyValue {
    return a.kv
}

{% for metric in ctx %}
{% set metric_name = smart_title_case(metric.metric_name) %}
{% set metric_attribute_struct_name = metric_name ~ "Attributes" %}
{% if metric.attributes | not_required | length > 0 %}
type {{ metric_name }}Attr interface {
    attr() attribute.KeyValue
}
{% endif %}


{# Create typesafe wrapper for counter #}
{{ ["An instrument for recording `" ~ metric.metric_name ~ "`"] | comment | trim }}
type {{ metric_name }} struct {
    inst metric.{{metric.instrument | map_text("metric_type_interface")}}
}

{{ ["Construct a new instrument for measuring `" ~ metric.metric_name ~ "`"] | comment }}
func New{{ metric_name }}(m metric.Meter) ({{ metric_name }}, error) {
    i, err := m.{{metric.instrument | map_text("metric_type_interface")}}(
        "{{metric.metric_name}}",
        metric.WithDescription("{{metric.brief}}"),
        metric.WithUnit("{{metric.unit}}"),
    )
    if err != nil {
        return {{metric_name}}{}, err
    }
    return {{ metric_name }}{i}, nil
}

{# TODO - a different wrapper method #}
{% if metric.attributes | length > 0 %}
{% if metric.attributes | not_required | length > 0 %}
func {{metric.metric_name | camel_case }}AttrToAttrs(in []{{metric_name}}Attr) []attribute.KeyValue {
	out := make([]attribute.KeyValue, len(in))
	for i, a := range in {
		out[i] = a.attr()
	}
	return out
}
{% endif %}

// Adds an increment to the existing count.
func (m {{ smart_title_case(metric.metric_name) }}) Add(
    ctx context.Context,
    inc float64,
{% for attr in metric.attributes | required | attribute_sort %}
    {{ attr.brief | trim | comment }}
    {{ attr.name | camel_case }} {{ attr.type | map_text("attribute_type_value")}},
{% endfor %}
{% if metric.attributes | not_required | length > 0 %}
    optAttrs ...{{metric_name}}Attr,
{% endif %}
) {
    {# TODO - handle other instrument types. #}
    m.inst.Add(ctx, inc, metric.WithAttributes(
        {% if metric.attributes | not_required | length > 0 %}
        append({{metric.metric_name | camel_case }}AttrToAttrs(optAttrs),
        {% endif %}
        {% for attr in metric.attributes | required | attribute_sort %}
        attribute.{{ attr.type | map_text("attribute_type_method")}}("{{ attr.name }}", {{ attr.name | camel_case }}),
        {% endfor %}
        {% if metric.attributes | not_required | length > 0 %}
        )...,
        {% endif %}
    ))
}
{% else %}
func (m {{ smart_title_case(metric.metric_name) }}) Add(ctx context.Context, inc float64) {
    (*m.instrument).Add(ctx, inc)
}
{% endif %}

{% for attr in metric.attributes | not_required | attribute_sort %}
func {{smart_title_case(attr.name)}}({{ attr.name | camel_case }} {{ attr.type | map_text("attribute_type_value")}}) {{metric_name}}Attr {
	return attr{attribute.{{ attr.type | map_text("attribute_type_method")}}("{{ attr.name }}", {{ attr.name | camel_case }})}
}
{% endfor %}


{% endfor %}
